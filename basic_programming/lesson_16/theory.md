<details style="margin-left: 20px;">
<summary><strong><em> Lesson 16. Введение в Объектно-Ориентированное Программирование: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

# Lesson 16. Введение в Объектно-Ориентированное Программирование (ООП)

## Введение в Объектно-Ориентированное Программирование (ООП) (10 минут)

#### Обзор: Что такое ООП
- **Определение ООП:**
    - Объектно-ориентированное программирование (ООП) - это парадигма программирования, которая использует "объекты" – структуры данных, состоящие из полей (атрибутов) и методов (функций), – для проектирования приложений и программ.
- **Роль ООП в Разработке:**
    - ООП позволяет программистам структурировать и организовывать код более эффективно, делая его более гибким, масштабируемым и легким для поддержки.
    - Подход, ориентированный на моделирование реального мира, облегчает понимание и управление сложными системами.

#### Краткий Исторический Контекст ООП
- **Развитие ООП:**
    - ООП начало развиваться в 1960-х годах с появлением языка программирования Simula, который ввел концепцию классов и объектов.
    - В 1970-х и 1980-х годах ООП продолжило развиваться с языками, такими как Smalltalk, который полностью основан на объектно-ориентированных принципах, и C++, который добавил объектно-ориентированные возможности к языку C.
- **Современное ООП:**
    - В настоящее время многие популярные языки программирования, такие как Java, C#, Python, и Ruby, поддерживают ООП.
    - ООП оказало значительное влияние на разработку программного обеспечения, в том числе на проектирование архитектуры программ, разработку фреймворков и проектирование пользовательских интерфейсов.

<details style="margin-left: 20px;">
<summary><strong><em> Бытовая аналогия: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

### Аналогия с Рестораном для Понимания Объектов в Программировании

#### Простой Java-Код (Рецепты в Ресторане):
- **Рецепты:** Как рецепты в ресторане дают точные инструкции по приготовлению блюд, простой Java-код представляет собой последовательность команд без "состояния". Он подобен четким указаниям, например, "добавить 100 грамм сахара".
- **Характеристики:** Такой код выполняется точно по инструкции, не сохраняет информацию о предыдущих действиях и не имеет внутреннего состояния.

#### Объекты в Программировании (Повара в Ресторане):
- **Повара:** Повара в ресторане, каждый со своими инструментами и методами приготовления, аналогичны объектам в ООП. Каждый повар (объект) может использовать общие рецепты (общий код), но при этом иметь свой стиль приготовления и ингредиенты (индивидуальное состояние и поведение).
- **Взаимодействие и Состояние:** Повара могут взаимодействовать друг с другом и "запоминать" разные состояния (например, количество доступных ингредиентов), что сравнимо с объектами, хранящими информацию в своих полях и взаимодействующими с помощью методов.

#### Вывод:
- **Простой код** в Java подобен **рецептам** – это фиксированные инструкции без внутреннего состояния.
- **Объекты** в программировании похожи на **поваров** в ресторане – они имеют свои уникальные характеристики и способы взаимодействия, обеспечивая гибкость и модульность в программе.

</details>

<details style="margin-left: 20px;">
<summary><strong><em> Разбор отдельных примеров: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

### Аналогии для Понимания Объектов в Программировании

<details style="margin-left: 20px;">
<summary><strong><em> Объект 1: Автомобиль: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

#### Объект 1: Автомобиль

- **Поля (Атрибуты):**
    - `цвет`: Определяет цвет автомобиля.
    - `марка`: Бренд или производитель автомобиля.
    - `текущаяСкорость`: Текущая скорость автомобиля.
    - `максимальнаяСкорость`: Максимально возможная скорость автомобиля.

- **Методы (Поведение):**
    - `ускорить(скорость)`: Увеличивает текущую скорость автомобиля.
    - `замедлить(скорость)`: Уменьшает текущую скорость автомобиля.
    - `показатьИнформацию()`: Отображает информацию об автомобиле.

<details style="margin-left: 20px;">
<summary><strong><em> Пример реализации в коде объекта автомобиль: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

![](images/01.png)

```java
public class Automobile {
    private String color;
    private String brand;
    private int currentSpeed;
    private int maxSpeed;

    // Конструктор класса Automobile
    public Automobile(String color, String brand, int maxSpeed) {
        this.color = color;
        this.brand = brand;
        this.maxSpeed = maxSpeed;
        this.currentSpeed = 0; // Начальная скорость равна 0
    }

    // Метод для ускорения автомобиля
    public void accelerate(int speed) {
        currentSpeed += speed;
        if (currentSpeed > maxSpeed) {
            currentSpeed = maxSpeed;
        }
    }

    // Метод для замедления автомобиля
    public void decelerate(int speed) {
        currentSpeed -= speed;
        if (currentSpeed < 0) {
            currentSpeed = 0;
        }
    }

    // Метод для отображения информации об автомобиле
    public void showInfo() {
        System.out.println("Автомобиль марки " + brand + ", цвет: " + color + ", текущая скорость: " + currentSpeed + " км/ч, максимальная скорость: " + maxSpeed + " км/ч.");
    }

    // Геттеры и сеттеры
    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getCurrentSpeed() {
        return currentSpeed;
    }

    public void setCurrentSpeed(int currentSpeed) {
        this.currentSpeed = currentSpeed;
    }

    public int getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(int maxSpeed) {
        this.maxSpeed = maxSpeed;
    }
}

```
</details>
</details>

<details style="margin-left: 20px;">
<summary><strong><em> Объект 2: Радио: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

#### Объект 2: Радио

- **Поля (Атрибуты):**
    - `громкость`: Уровень громкости радио.
    - `текущаяСтанция`: Играющая в данный момент радиостанция.
    - `включено`: Состояние радио (включено/выключено).

- **Методы (Поведение):**
    - `включить()`: Включает радио.
    - `выключить()`: Выключает радио.
    - `сменитьСтанцию(станция)`: Переключает на другую радиостанцию.
    - `регулироватьГромкость(уровень)`: Изменяет уровень громкости радио.

<details style="margin-left: 20px;">
<summary><strong><em> Пример реализации в коде объекта Радио: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

![](images/03.png)

```java
public class Radio {
    private int volume;
    private String currentStation;
    private boolean isOn;

    // Конструктор класса Radio
    public Radio() {
        this.volume = 0; // Начальный уровень громкости
        this.currentStation = "Не выбрана"; // Начальная радиостанция
        this.isOn = false; // Радио изначально выключено
    }

    // Метод для включения радио
    public void turnOn() {
        isOn = true;
        System.out.println("Радио включено.");
    }

    // Метод для выключения радио
    public void turnOff() {
        isOn = false;
        System.out.println("Радио выключено.");
    }

    // Метод для смены радиостанции
    public void changeStation(String station) {
        if (isOn) {
            currentStation = station;
            System.out.println("Переключено на станцию: " + station);
        } else {
            System.out.println("Радио выключено. Смена станции невозможна.");
        }
    }

    // Метод для регулировки громкости
    public void adjustVolume(int level) {
        if (isOn) {
            volume = level;
            System.out.println("Громкость установлена на уровень: " + level);
        } else {
            System.out.println("Радио выключено. Регулировка громкости невозможна.");
        }
    }

    // Геттеры и сеттеры
    public int getVolume() {
        return volume;
    }

    public void setVolume(int volume) {
        this.volume = volume;
    }

    public String getCurrentStation() {
        return currentStation;
    }

    public void setCurrentStation(String currentStation) {
        this.currentStation = currentStation;
    }

    public boolean isOn() {
        return isOn;
    }

    public void setOn(boolean isOn) {
        this.isOn = isOn;
    }
}
```
</details>
</details>

<details style="margin-left: 20px;">
<summary><strong><em> Объект 3: Кофеварка: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

#### Объект 3: Кофеварка
- **Поля (Атрибуты):**
    - `уровеньВоды`: Количество воды в кофеварке.
    - `температура`: Температура нагрева воды.
    - `типКофе`: Тип кофе, который используется (например, эспрессо, американо).

- **Методы (Поведение):**
    - `сделатьКофе()`: Готовит кофе согласно заданным параметрам.
    - `очистить()`: Очищает кофеварку.
    - `заполнитьВодой(количество)`: Добавляет воду в кофеварку.


<details style="margin-left: 20px;">
<summary><strong><em> Пример реализации в коде объекта Кофеварка: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

```java
public class CoffeeMaker {
    private int waterLevel;
    private int temperature;
    private String coffeeType;

    // Конструктор класса CoffeeMaker
    public CoffeeMaker() {
        this.waterLevel = 0; // Начальный уровень воды
        this.temperature = 90; // Начальная температура для кофе
        this.coffeeType = "не выбран"; // Начальный тип кофе
    }

    // Метод для приготовления кофе
    public void makeCoffee() {
        if (waterLevel > 0 && !coffeeType.equals("не выбран")) {
            System.out.println("Готовлю " + coffeeType + " при температуре " + temperature + "°C.");
            // Предположим, что приготовление кофе уменьшает уровень воды
            waterLevel -= 50;
            if (waterLevel < 0) {
                waterLevel = 0;
            }
            System.out.println("Кофе готов! Осталось воды: " + waterLevel + " мл.");
        } else {
            System.out.println("Пожалуйста, добавьте воду и выберите тип кофе.");
        }
    }

    // Метод для очистки кофеварки
    public void clean() {
        System.out.println("Кофеварка очищена.");
    }

    // Метод для добавления воды в кофеварку
    public void fillWater(int amount) {
        waterLevel += amount;
        System.out.println("Добавлено " + amount + " мл воды. Текущий уровень воды: " + waterLevel + " мл.");
    }

    // Геттеры и сеттеры
    public int getWaterLevel() {
        return waterLevel;
    }

    public void setWaterLevel(int waterLevel) {
        this.waterLevel = waterLevel;
    }

    public int getTemperature() {
        return temperature;
    }

    public void setTemperature(int temperature) {
        this.temperature = temperature;
    }

    public String getCoffeeType() {
        return coffeeType;
    }

    public void setCoffeeType(String coffeeType) {
        this.coffeeType = coffeeType;
    }
}
```
</details>
</details>

<details style="margin-left: 20px;">
<summary><strong><em> Объект 4: Умные Часы: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

#### Объект 4: Умные Часы
- **Поля (Атрибуты):**
    - `время`: Текущее время.
    - `шаги`: Количество пройденных шагов.
    - `уведомления`: Список активных уведомлений.

- **Методы (Поведение):**
    - `показатьВремя()`: Отображает текущее время.
    - `отследитьШаги()`: Обновляет и отображает количество шагов.
    - `получитьУведомление(сообщение)`: Добавляет новое уведомление в список.

<details style="margin-left: 20px;">
<summary><strong><em> Пример реализации в коде объекта Кофеварка: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

```java
import java.util.ArrayList;
import java.util.List;

public class SmartWatch {
    private String currentTime;
    private int steps;
    private List<String> notifications;

    // Конструктор класса SmartWatch
    public SmartWatch() {
        this.currentTime = "12:00"; // Начальное время
        this.steps = 0; // Начальное количество шагов
        this.notifications = new ArrayList<>(); // Инициализация списка уведомлений
    }

    // Метод для отображения текущего времени
    public void showTime() {
        System.out.println("Текущее время: " + currentTime);
    }

    // Метод для отслеживания шагов
    public void trackSteps() {
        // Предполагаем, что метод каким-то образом обновляет количество шагов
        steps += 100; // Пример добавления шагов
        System.out.println("Количество пройденных шагов: " + steps);
    }

    // Метод для получения уведомления
    public void receiveNotification(String message) {
        notifications.add(message);
        System.out.println("Новое уведомление: " + message);
    }

    // Геттеры и сеттеры
    public String getCurrentTime() {
        return currentTime;
    }

    public void setCurrentTime(String currentTime) {
        this.currentTime = currentTime;
    }

    public int getSteps() {
        return steps;
    }

    public void setSteps(int steps) {
        this.steps = steps;
    }

    public List<String> getNotifications() {
        return notifications;
    }

    // Дополнительный метод для отображения всех уведомлений
    public void showNotifications() {
        if (notifications.isEmpty()) {
            System.out.println("Нет уведомлений.");
        } else {
            System.out.println("Уведомления:");
            for (String notification : notifications) {
                System.out.println("- " + notification);
            }
        }
    }
}
```
</details>
</details>

<details style="margin-left: 20px;">
<summary><strong><em> Объект 5: Библиотека: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

#### Объект 5: Библиотека
- **Поля (Атрибуты):**
    - `книги`: Список книг в библиотеке.
    - `адрес`: Адрес библиотеки.
    - `часыРаботы`: Часы работы библиотеки.

- **Методы (Поведение):**
    - `добавитьКнигу(книга)`: Добавляет новую книгу в библиотеку.
    - `найтиКнигу(название)`: Ищет книгу по названию.
    - `зарегистрироватьПосетителя(посетитель)`: Регистрирует нового посетителя в библиотеке.

<details style="margin-left: 20px;">
<summary><strong><em> Пример реализации в коде объекта Библиотека: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

![](images/05.webp)

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Library {
    private List<String> books;
    private String address;
    private String hoursOfWork;
    private Map<String, Boolean> visitors;

    // Конструктор класса Library
    public Library(String address, String hoursOfWork) {
        this.books = new ArrayList<>();
        this.address = address;
        this.hoursOfWork = hoursOfWork;
        this.visitors = new HashMap<>();
    }

    // Метод для добавления новой книги в библиотеку
    public void addBook(String book) {
        books.add(book);
        System.out.println("Книга \"" + book + "\" добавлена в библиотеку.");
    }

    // Метод для поиска книги по названию
    public boolean findBook(String title) {
        for (String book : books) {
            if (book.equalsIgnoreCase(title)) {
                System.out.println("Книга найдена: " + book);
                return true;
            }
        }
        System.out.println("Книга \"" + title + "\" не найдена.");
        return false;
    }

    // Метод для регистрации нового посетителя в библиотеке
    public void registerVisitor(String visitorName) {
        visitors.put(visitorName, true);
        System.out.println("Посетитель " + visitorName + " зарегистрирован в библиотеке.");
    }

    // Геттеры и сеттеры
    public List<String> getBooks() {
        return books;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getHoursOfWork() {
        return hoursOfWork;
    }

    public void setHoursOfWork(String hoursOfWork) {
        this.hoursOfWork = hoursOfWork;
    }

    public Map<String, Boolean> getVisitors() {
        return visitors;
    }
}

```
</details>
</details>
</details>
</details>

---------------------

<details style="margin-left: 20px;">
<summary><strong><em> Lesson 17. ООП. Модификаторы доступа, геттеры и сеттеры: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

# Lesson 17

## Введение

### Краткое напоминание о предыдущем уроке (объекты, классы, конструкторы)
На предыдущем уроке мы изучали основные концепции объектно-ориентированного программирования на примере Java:
- **Объекты**: Мы узнали, что объекты - это экземпляры классов, обладающие состоянием (свойствами) и поведением (методами).
- **Классы**: Классы являются шаблонами для создания объектов, определяющими их структуру и поведение.
- **Конструкторы**: Мы рассмотрели, как конструкторы используются для инициализации новых объектов, устанавливая начальные значения для полей объекта.

### Объяснение целей сегодняшнего урока
Сегодня мы продолжим изучение объектно-ориентированного программирования в Java, сосредоточив внимание на следующих темах:
1. **Модификаторы доступа**: Узнаем, как они определяют область видимости и доступ к членам класса (полям, методам).
2. **Статические и нестатические поля и методы**: Поймем разницу между статическими (принадлежащими классу) и нестатическими (принадлежащими объектам) членами.
3. **Геттеры и Сеттеры**: Научимся использовать эти методы для доступа и обновления значений полей объекта, соблюдая принципы инкапсуляции.

Цель сегодняшнего урока - углубить понимание этих ключевых аспектов ООП, что позволит создавать более эффективный и безопасный код на Java.


## 2. Модификаторы доступа

### Определение модификаторов доступа
Модификаторы доступа в Java - это ключевые слова, которые устанавливают уровень доступа к классам, методам, конструкторам и переменным. Они определяют, откуда может быть доступен член класса (метод или переменная) - из этого класса, пакета, подкласса или вообще из любого места.

### Примеры: `public`, `private`, `protected`, `package-private`
- **`public`**: Этот модификатор позволяет доступ к члену класса из любого другого класса в программе. Нет ограничений на доступ.
- **`private`**: Противоположность `public`. Доступ к члену класса возможен только внутри самого класса.
- **`protected`**: Доступ к члену класса разрешён из любого класса в том же пакете, а также из подклассов, даже если они в других пакетах.
- **`package-private`** (без модификатора): Если модификатор доступа не указан, то по умолчанию используется `package-private`. Это означает, что доступ возможен только внутри того же пакета.

### Практические примеры использования в классах и методах
Давайте рассмотрим пример класса с разными модификаторами доступа:

```java
public class ExampleClass {
    public int publicVar = 10;   // Доступно везде
    private int privateVar = 20; // Доступно только в ExampleClass
    protected int protectedVar = 30; // Доступно в подклассах и в пакете
    int packagePrivateVar = 40;  // Доступно в пакете

    public void publicMethod() {
        // метод доступен везде
    }

    private void privateMethod() {
        // метод доступен только в ExampleClass
    }

    protected void protectedMethod() {
        // метод доступен в подклассах и в пакете
    }

    void packagePrivateMethod() {
        // метод доступен в пакете
    }
}
```

<details style="margin-left: 20px;">
<summary><strong><em> Бытовая аналогия: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

## Аналогия Модификаторов Доступа

Модификаторы доступа в Java можно сравнить с доступом к разным пространствам в жилом доме:

### 1. `public` (Общедоступный)
- **Аналогия**: Как городская площадь или общественный парк.
- **Описание**: Доступен каждому, кто желает воспользоваться пространством или предметами.

### 2. `private` (Частный)
- **Аналогия**: Как ваша личная спальня в доме.
- **Описание**: Доступ ограничен исключительно владельцем или очень ограниченным кругом лиц.

### 3. `protected` (Защищённый)
- **Аналогия**: Как гостиная в семейном доме.
- **Описание**: Доступно членам семьи (аналог подклассов) и гостям в доме (тот же пакет), но недоступно для посторонних.

### 4. `package-private` (Пакетный уровень доступа)
- **Аналогия**: Как элементы в общей кухне коммунальной квартиры.
- **Описание**: Доступно жильцам этой квартиры (классы в том же пакете), но недоступно для жильцов других квартир (других пакетов).

Эта аналогия помогает понять, как различные модификаторы доступа ограничивают или расширяют доступ к классам, методам и переменным в Java.

</details>

<details style="margin-left: 20px;">
<summary><strong><em> Простое Объяснение Модификаторов Доступа в Java: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>


## Простое Объяснение Модификаторов Доступа в Java

### `private` (Частный)
- **Цель**: Сохранить важные данные или функции внутри класса, скрытые от всех.
- **Как это работает**: Это как иметь личный дневник, который только вы можете читать и писать в него.
- **Почему это важно**: Чтобы предотвратить случайные изменения или просмотр чувствительных данных другими частями программы.

### `public` (Общедоступный)
- **Цель**: Сделать методы или данные доступными для всех.
- **Как это работает**: Это как общедоступный объявлений на доске, к которому может обратиться любой.
- **Почему это важно**: Чтобы разные части программы могли свободно взаимодействовать с этими элементами.

### `protected` (Защищённый)
- **Цель**: Позволить доступ к данным или функциям только "родственным" классам.
- **Как это работает**: Это как секреты, которыми вы делитесь только с близкими родственниками.
- **Почему это важно**: Чтобы подклассы могли использовать и изменять эти данные, сохраняя контроль над доступом.

### `package-private` (Уровень пакета)
- **Цель**: Ограничить доступ в пределах одного "района" или пакета классов.
- **Как это работает**: Это как закрытый клуб в районе, куда могут зайти только жители этого района.
- **Почему это важно**: Для упорядочивания и защиты данных в рамках одного пакета, не позволяя внешним классам вмешиваться.

Эти модификаторы доступа помогают контролировать, как разные части программы взаимодействуют друг с другом, обеспечивая безопасность и порядок в структуре программы.
</details>


## Статические и Нестатические Поля и Методы в Java

### Определение и различия
- **Статические поля и методы** принадлежат классу в целом, а не отдельному объекту. Они общие для всех экземпляров класса.
- **Нестатические поля и методы** принадлежат конкретному объекту, созданному из класса, и каждый объект имеет свои копии этих полей и методов.

### Примеры статических методов и полей
- **Пример поля**: Счётчик, который отслеживает количество созданных объектов класса.
- **Пример метода**: Метод, который возвращает информацию о классе или выполняет операции, не зависящие от конкретного объекта.

### Примеры нестатических методов и полей
- **Пример поля**: Значение, уникальное для каждого объекта, например, имя пользователя.
- **Пример метода**: Метод, который работает с уникальными данными объекта, например, выводит имя пользователя.

### Практическое применение: когда и как использовать
- **Использование статических полей и методов**:
  - Когда нужна информация или функциональность, общая для всех экземпляров класса.
  - Пример: методы-помощники (utility methods), константы.
- **Использование нестатических полей и методов**:
  - Когда данные или функциональность связаны с конкретным экземпляром класса.
  - Пример: методы, изменяющие состояние объекта, или поля, уникальные для каждого объекта.

<details style="margin-left: 20px;">
<summary><strong><em> Аналогия: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>


Представьте класс как школу. Статическое поле – это, например, количество всех учеников в школе, а нестатическое поле –
это имя конкретного ученика. Статический метод может быть что-то вроде "получить общее количество учеников в школе",
тогда как нестатический метод мог бы "вывести имя ученика".

</details>

Выбор между статическим и нестатическим подходом зависит от того, нужна ли функциональность или данные на уровне класса в целом или на уровне конкретных объектов.

<details style="margin-left: 20px;">
<summary><strong><em> Пример кода: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

```java
public class Counter {
    // Статическое поле для отслеживания количества экземпляров класса Counter
    private static int count = 0;

    // Конструктор, увеличивающий счетчик при создании нового экземпляра
    public Counter() {
        count++;
    }

    // Статический метод для получения текущего значения счетчика
    public static int getCount() {
        return count;
    }

    // Пример использования класса Counter
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();

        // Вывод количества созданных экземпляров класса Counter
        System.out.println("Создано экземпляров Counter: " + Counter.getCount());
    }
}

```

В этом примере:

- `count` является статическим полем, которое считает количество созданных экземпляров класса `Counter`.
- Каждый раз при создании нового объекта класса `Counter`, конструктор увеличивает значение `count`.
- Статический метод `getCount` возвращает текущее значение счетчика.
- В методе `main` мы создаём три экземпляра `Counter` и затем выводим количество созданных экземпляров.
</details>

## Повторение Конструкторов

### Краткое напоминание о конструкторах
Конструкторы в Java - это специальные методы, которые вызываются при создании нового объекта класса. Они обычно используются для инициализации объекта, например, для присвоения начальных значений полям. Конструкторы имеют те же имя, что и класс, и не имеют возвращаемого типа.

### Перегрузка конструкторов
Перегрузка конструкторов означает создание нескольких конструкторов с одинаковым именем, но с разными параметрами. Это позволяет создавать объекты класса с разными начальными данными.

### Примеры с разными типами конструкторов
Приведём пример класса с разными типами конструкторов:

<details style="margin-left: 20px;">
<summary><strong><em> Пример кода: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

```java
public class Book {
    private String title;
    private String author;
    private int year;

    // Конструктор по умолчанию
    public Book() {
        this.title = "Неизвестно";
        this.author = "Неизвестно";
        this.year = 0;
    }

    // Конструктор с одним параметром
    public Book(String title) {
        this.title = title;
        this.author = "Неизвестно";
        this.year = 0;
    }

    // Конструктор с двумя параметрами
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
        this.year = 0;
    }

    // Конструктор с тремя параметрами
    public Book(String title, String author, int year) {
        this.title = title;
        this.author = author;
        this.year = year;
    }

    // Методы доступа (геттеры) для полей класса...
}
```

В этом примере класс `Book` имеет четыре конструктора, каждый из которых принимает разное количество параметров. Это
позволяет создавать объекты Book с различными начальными данными.

Таким образом, перегрузка конструкторов обеспечивает гибкость при создании объектов класса, позволяя инициализировать их
различными способами.
</details>

<details style="margin-left: 20px;">
<summary><strong><em> Бытовая аналогия: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

## Бытовая Аналогия для Конструктора и Перегрузки Конструкторов

### Аналогия для Конструктора

Конструктор в программировании можно сравнить с процессом постройки дома по определённому плану. Как и в постройке дома,
где у вас есть различные параметры (например, количество комнат, цвет стен, наличие гаража), конструктор в классе
определяет, как создаётся объект и какие начальные значения ему присваиваются.

- **Пример**: Представьте, что вы строите дом. Конструктор - это план строительства, который говорит, как дом должен
  быть построен и что в него включено.

### Аналогия для Перегрузки Конструкторов

Перегрузка конструкторов подобна наличию нескольких вариантов планов для постройки домов. Каждый план предлагает разные
опции - один может включать гараж, другой - большой сад, а третий - бассейн. Выбор плана зависит от того, что вы хотите
иметь в своём доме.

- **Пример**: Вы решаете построить дом, и у вас есть несколько планов на выбор:
  - Основной план (конструктор по умолчанию) - строится стандартный дом.
  - План с дополнительными опциями (перегруженный конструктор) - строится дом с дополнительными удобствами, такими как
    гараж или сад.

Каждый "план" (конструктор) позволяет создать "дом" (объект) с различными характеристиками, в зависимости от того, какие
параметры вы выбрали. Это обеспечивает гибкость при создании объектов в программировании.

</details>


## 5. Геттеры и Сеттеры

### Определение геттеров и сеттеров
Геттеры (Getters) и сеттеры (Setters) – это методы в объектно-ориентированном программировании, используемые для доступа и обновления значений полей объекта.

- **Геттеры** - методы, которые возвращают значение поля объекта.
- **Сеттеры** - методы, которые позволяют устанавливать или изменять значение поля объекта.

### Почему и когда использовать геттеры и сеттеры
- **Защита данных**: Геттеры и сеттеры позволяют контролировать, как внешние классы получают доступ к полям объекта, предотвращая неправильное использование или изменение данных.
- **Гибкость**: Можно изменить способ хранения данных, не влияя на классы, которые используют эти данные.
- **Добавление логики**: Можно вставлять дополнительную логику при получении или установке значения, например, проверку допустимости данных.

### Создание геттеров и сеттеров на примерах
Пример класса с геттерами и сеттерами:

```java
public class Person {
    private String name;
    private int age;

    // Конструктор
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Геттер для имени
    public String getName() {
        return name;
    }

    // Сеттер для имени
    public void setName(String name) {
        this.name = name;
    }

    // Геттер для возраста
    public int getAge() {
        return age;
    }

    // Сеттер для возраста
    public void setAge(int age) {
        if (age > 0) {
            this.age = age;
        }
    }
}
```

В этом примере класс `Person` имеет приватные поля `name` и `age`. Геттеры (`getName` и `getAge`) возвращают значения этих полей,
а сеттеры (`setName` и `setAge`) позволяют изменять их, при этом сеттер `setAge` включает проверку допустимости значения.

### Инкапсуляция данных через геттеры и сеттеры
Использование геттеров и сеттеров является ключевым аспектом инкапсуляции в объектно-ориентированном программировании.
Они обеспечивают безопасный доступ к данным объекта, скрывая внутреннюю реализацию и защищая данные от нежелательного
воздействия.

### Почему важно использовать геттеры и сеттеры, а не просто давать доступ к полям

#### 1. Инкапсуляция и Защита данных
- **Скрытие реализации**: Геттеры и сеттеры скрывают внутреннюю реализацию класса. Это означает, что можно изменять внутреннюю структуру класса, не затрагивая те части программы, которые используют этот класс.
- **Контроль доступа**: Предоставляя только геттеры, можно сделать поля класса доступными только для чтения. Аналогично, можно предоставить только сеттеры для полей, которые должны быть доступны только для записи.

#### 2. Валидация данных
- **Проверка вводимых данных**: Сеттеры позволяют вставлять логику проверки данных, гарантируя, что в поле не будет установлено недопустимое значение.
- **Пример**: В сеттере для возраста (`setAge`) можно убедиться, что возраст не отрицателен.

#### 3. Дополнительная логика
- **Добавление дополнительного кода**: В геттерах и сеттерах можно реализовать дополнительную логику, например, логирование, отложенную инициализацию и т.д.
- **Пример**: В геттере можно реализовать логику "ленивой загрузки" (lazy loading), загружая данные при первом обращении.

#### 4. Удобство поддержки и расширения
- **Легкость обновления и поддержки**: Использование геттеров и сеттеров делает код более удобным для поддержки и обновления. Можно легко отслеживать, где и как используются поля класса.
- **Совместимость с фреймворками**: Многие фреймворки Java, такие как Spring или Hibernate, основаны на паттернах с использованием геттеров и сеттеров.

#### 5. Поддержка принципов ООП
- **Соответствие принципам объектно-ориентированного программирования**: Геттеры и сеттеры помогают следовать принципам ООП, таким как инкапсуляция и абстракция, обеспечивая более чистую и организованную структуру кода.

#### 6. Удобство тестирования
- **Облегчение процесса тестирования**: Тестирование классов с инкапсуляцией через геттеры и сеттеры обычно проще, так как можно легко установить и проверить состояние объекта.

Использование геттеров и сеттеров вместо прямого доступа к полям помогает создавать более безопасный, гибкий и легко поддерживаемый код. Это ключевые аспекты качественного программного обеспечения.

<details style="margin-left: 20px;">
<summary><strong><em> Пример кода: (нажмите на треугольник, чтобы развернуть текст)</em></strong></summary>

```java
public class Employee {
    public String name;
    public int age;
    public double salary;

    public Employee(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
}
```

В этом классе `Employee`, поля `name`, `age` и `salary` являются общедоступными (`public`). Это позволяет напрямую изменять эти
поля из внешнего кода, что может привести к следующим проблемам:

### Потенциальные Ошибки
Неправильная Валидация: Данные могут быть изменены без проверки допустимости. Например, возраст может быть установлен в
отрицательное значение, что является недопустимым.

```java
Employee emp = new Employee("John", 30, 5000.0);
emp.age = -5; // Недопустимое значение, но возможно из-за прямого доступа
```

### Неконтролируемое Изменение:
Внешние классы могут изменять состояние объекта `Employee` без его ведома, что может привести
к непредсказуемому поведению программы.

`emp.salary = 1000000; // Значение зарплаты изменено напрямую, что может быть ошибкой`


### Отсутствие Гибкости:
Если потребуется изменить логику работы с данными (например, добавить округление для зарплаты),
придется искать и изменять каждое место в коде, где происходит доступ к этому полю.

```java
// Везде, где изменяется зарплата, нужно будет добавить логику округления
emp.salary = Math.round(4567.89);
```

### Проблемы с Отладкой:
Сложнее отслеживать, где и как меняются данные, так как изменения могут происходить в любой части
программы, что затрудняет отладку и поиск ошибок.

Вывод
Использование геттеров и сеттеров вместо прямого доступа к полям позволяет лучше контролировать данные, обеспечивать их
валидацию, гибкость и удобство в поддержке кода.
</details>




</details>

----------------------